/*
 * main.c
 *
 *  Created on: May 18, 2021
 *      Author: Kristijan Ceple
 */

/*
 * appa.c - Contains Appendix A Code Demo
 *
 *  Created on: May 18, 2021
 *      Author: Kristijan Ceple
 */
#include "xmk.h"
#include "sys/init.h"
#include "xgpio.h"
#include <pthread.h>
#include <unistd.h>
#include "xuartlite.h"
#include "xparameters.h"
#include <sys/timer.h> //for using sleep. need to set config_time to true
#include <sys/intr.h> //xilkernel api for interrupts
#include <sys/process.h>
#include <stdio.h>
#define XST_SUCCESS 0L
#define XST_FAILURE 1L
#define true 1
#define false 0
typedef unsigned char bool;
#define TASK_THREADS_NUM 8
#define TASK_THREADS_PERIODIC_NUM 3
#define TASK_THREADS_NONPERIODIC_NUM 5
#define TASK_THREADS_PERIODIC_OFFSET 0
#define TASK_THREADS_NONPERIODIC_OFFSET 3
#define SLEEP_AMOUNT 50
#define WORK_AMOUNT 500

unsigned char task_threads_activity;
pthread_mutexattr_t mattr;
pthread_mutex_t  mutex_task_threads_activity;
pthread_t task_threads_pids[TASK_THREADS_NUM];
sem_t tthread_sems[TASK_THREADS_NONPERIODIC_NUM];
XGpio gpDIP, gpPUSH, gpLED; //PB device instance.

pthread_t tid1, tid2, tid3, tid4, tid5, tid6, tid7, tid8;
extern void* clock_main (void *);

static pid_t spid;
static pthread_t tid;
static pthread_attr_t attr;
static p_stat shell_ps;
static struct sched_param spar;
extern volatile int hrs, mins, secs, tot_secs;


void task(int thread_id) {
	xil_printf("Thread ID: %d wörking!\r\n", thread_id);
	sleep(WORK_AMOUNT);
	xil_printf("Thread ID: %d done!\r\n", thread_id);
}

static void gpDIPIntHandler(void *arg) //Should be very short (in time). In a practical program, don't print etc.
{
	unsigned char val;
//clear the interrupt flag. if this is not done, gpio will keep interrupting the microblaze.--
	XGpio_InterruptClear(&gpDIP, 1);

	val = XGpio_DiscreteRead(&gpDIP, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);
}

static void gpPUSHIntHandler(void *arg) //Should be very short (in time). In a practical program, don't print etc.
{
	unsigned char val;
	int my_id = 0;
//clear the interrupt flag. if this is not done, gpio will keep interrupting the microblaze.--
	XGpio_InterruptClear(&gpPUSH, 1);

	val = XGpio_DiscreteRead(&gpPUSH, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);
}

void* periodic_thread(void* arg) {
	int time_tracker_ms, current_time_ms, former_time_ms;
	unsigned char tmp;
	int my_id = (int)arg;
	int my_period_ms = 1000*pow(2,my_id+1);

	xil_printf("Periodic thread ID: %d(period %d) reporting!\r\n", my_id, my_period_ms);

	time_tracker_ms = my_period_ms;
	while (1) {
		// First check if I am active?
		pthread_mutex_lock(&mutex_task_threads_activity);
		tmp = task_threads_activity;
		pthread_mutex_unlock(&mutex_task_threads_activity);

		tmp >>= my_id;
		tmp &= 0x01;

		former_time_ms = current_time_ms;
		current_time_ms = tot_secs;

		if(tmp == 1) {
			// Active
			if(current_time_ms > time_tracker_ms) {
				task(my_id);
				time_tracker_ms += my_period_ms;
			} else {
				sleep(SLEEP_AMOUNT);
			}
		} else {
			// Frozen
			time_tracker_ms += (current_time_ms - former_time_ms)*1000;
			sleep(SLEEP_AMOUNT);
		}

	}
}

void* non_periodic_thread(void* arg) {
	int time_tracker, current_time;
	unsigned char tmp;
	int my_id = (int)arg;

	xil_printf("Non-Periodic thread ID: %d reporting!\r\n", my_id);

	while (1) {
		// First check if I am active?
		pthread_mutex_lock(&mutex_task_threads_activity);
		tmp = task_threads_activity;
		pthread_mutex_unlock(&mutex_task_threads_activity);

		tmp >>= my_id;
		tmp &= 0x01;

		if(tmp == 1) {
			// Active
			task(my_id);
			sleep(5000);
		} else {
			sleep(50);
		}

	}
}

void start_clock()
{
    int ret;

    pthread_attr_init(&attr);                                                          /* Need to launch a thread */
    spar.sched_priority = 0;
    pthread_attr_setschedparam(&attr,&spar);

    ret = pthread_create(&tid, &attr, (void*)clock_main, NULL);

    if (ret != 0) {
        xil_printf ("-- ERROR (%d) launching clock thread. Clock services unavailable...\r\n", ret);
    }

}

void clear()
{
    int i = 0 ;
    for(; i < 80; i++ ) {
    	outbyte('\r') ; outbyte('\n') ;
    }
}

void shell_main(void* arg) {
	print("SHELL: Starting clock...\r\n");
	start_clock();
	print("\r\n\r\n");
	clear();

	unsigned char val;
	int Status;
	int ret, retval_tmp, i;

	task_threads_activity = 0b10101010;

	// Set my priority as highest - 0!
	spar.sched_priority = 0;
	spid = get_currentPID();
	pthread_setschedparam(spid, NULL, &spar);

	// Initialise mutex and semaphores
	retval_tmp = pthread_mutexattr_init (&mattr);
	if (retval_tmp != 0) {
		xil_printf ("Error during pthread_mutexattr_init: %d.\r\n", retval_tmp);
		pthread_exit(NULL);
	}

	retval_tmp = pthread_mutex_init (&mutex_task_threads_activity, &mattr);
	if (retval_tmp != 0) {
		xil_printf ("Error during pthread_mutex_init: %d.\r\n", retval_tmp);
		pthread_exit(NULL);
	}

//	for(i = TASK_THREADS_NONPERIODIC_OFFSET; i < TASK_THREADS_NONPERIODIC_OFFSET + TASK_THREADS_NONPERIODIC_NUM; i++) {
//		if( sem_init(&tthread_sems[i], 1, 1) < 0 ) {
//			print("SEM: Error while initializing semaphore 1.\r\n");
//			pthread_exit(NULL);
//		}
//	}

	// Initialise LED
	Status = XGpio_Initialize(&gpLED, XPAR_LED_GPIO_DEVICE_ID);
	XGpio_SetDataDirection(&gpLED, 1, 0x00000000);
	XGpio_DiscreteWrite(&gpLED, 1, 0x00);
	print("Initializing DIP\r\n");

	// Initialise the DIP instance & PUSH
	Status = XGpio_Initialize(&gpDIP, XPAR_DIP_GPIO_DEVICE_ID);
	Status = XGpio_Initialize(&gpPUSH, XPAR_PUSH_GPIO_DEVICE_ID);

	// Set DP & PUSH gpio direction to input.
	XGpio_SetDataDirection(&gpDIP, 1, 0x000000FF);
	XGpio_SetDataDirection(&gpPUSH, 1, 0x000000FF);

	print("Enabling DIP interrupts\r\n");
	//global enable
	XGpio_InterruptGlobalEnable(&gpDIP);
	// interrupt enable. both global enable and this function should be called to enable gpio interrupts.
	XGpio_InterruptEnable(&gpDIP, 1);
	//register the handler with xilkernel
	register_int_handler(XPAR_AXI_INTC_0_DIP_GPIO_IP2INTC_IRPT_INTR,
			gpDIPIntHandler, &gpDIP);
	//enable the interrupt in xilkernel
	enable_interrupt(XPAR_AXI_INTC_0_DIP_GPIO_IP2INTC_IRPT_INTR);
	print("DIP int enabled\r\n");
	print("Enabling PUSH interrupts\r\n");
	//global enable
	XGpio_InterruptGlobalEnable(&gpPUSH);

	// interrupt enable. both global enable and this function should be called to enable gpio interrupts.
	XGpio_InterruptEnable(&gpPUSH, 1);
	//register the handler with xilkernel
	register_int_handler(XPAR_AXI_INTC_0_PUSH_GPIO_IP2INTC_IRPT_INTR,
			gpPUSHIntHandler, &gpPUSH);
	//enable the interrupt in xilkernel
	enable_interrupt(XPAR_AXI_INTC_0_PUSH_GPIO_IP2INTC_IRPT_INTR);
	print("PUSH int enabled\r\n");

	// Write starting state
	val = XGpio_DiscreteRead(&gpDIP, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);

//	//start thread 1 -- Left Over for reference!
//	ret = pthread_create(&tid1, NULL, (void*) thread_tut_func_1, NULL );
//	if (ret != 0) {
//		xil_printf("-- ERROR (%d) launching thread_tut_func_1...\r\n", ret);
//	} else {
//		xil_printf("Thread 1 launched with ID %d \r\n", tid1);
//	}

	pthread_attr_t tmp_pthread_attr;
	pthread_attr_init(&tmp);

	// Start periodic threads
	for(i = TASK_THREADS_PERIODIC_OFFSET; i < TASK_THREADS_PERIODIC_NUM; i++) {
		tmp_pthread_attr.schedparam.sched_priority = i;
		ret = pthread_create(&task_threads_pids[i], &tmp_pthread_attr, (void*)periodic_thread, (void*)i);
		if (ret != 0) {
			xil_printf("-- ERROR (%d) launching thread...\r\n", ret);
		} else {
			xil_printf("Periodic thread launched with ID %d \r\n", task_threads_pids[i]);
		}
	}

	// Start nonperiodic threads
	for(i = TASK_THREADS_NONPERIODIC_OFFSET; i < TASK_THREADS_NONPERIODIC_OFFSET + TASK_THREADS_NONPERIODIC_NUM; i++) {
		tmp_pthread_attr.schedparam.sched_priority = i;
		ret = pthread_create(&task_threads_pids[i], &tmp_pthread_attr, (void*)non_periodic_thread, (void*)i);
		if (ret != 0) {
			xil_printf("-- ERROR (%d) launching thread...\r\n", ret);
		} else {
			xil_printf("NonPeriodic thread launched with ID %d \r\n", task_threads_pids[i]);
		}
	}

	return 0;
}

int main ()
{
	xil_printf("Main started!\r\n");
    xilkernel_main ();
}

//int main_example() {
//	print("-- Entering main() --\r\n");
////Initialize Xilkernel
//	xilkernel_init();
////Add main_prog as the static thread that will be invoked by Xilkernel
//	xmk_add_static_thread(main_prog, 0);
////Start Xilkernel
//	xilkernel_start();
//	/* Never reached */
//	return 0;
//}
