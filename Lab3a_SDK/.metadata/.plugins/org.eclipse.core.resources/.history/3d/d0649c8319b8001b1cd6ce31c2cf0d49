/*
 * main.c
 *
 *  Created on: May 18, 2021
 *      Author: Kristijan Ceple
 */

/*
 * appa.c - Contains Appendix A Code Demo
 *
 *  Created on: May 18, 2021
 *      Author: Kristijan Ceple
 */
#include "xmk.h"
#include "sys/init.h"
#include "xgpio.h"
#include <pthread.h>
#include <unistd.h>
#include "xuartlite.h"
#include "xparameters.h"
#include <sys/timer.h> //for using sleep. need to set config_time to true
#include <sys/intr.h> //xilkernel api for interrupts
#include <sys/process.h>
#include <stdio.h>
#define XST_SUCCESS 0L
#define XST_FAILURE 1L
#define true 1
#define false 0
typedef unsigned char bool;
#define TASK_THREADS_NUM 8
#define TASK_THREADS_PERIODIC_NUM 3
#define TASK_THREADS_NONPERIODIC_NUM 5
#define TASK_THREADS_PERIODIC_OFFSET 0
#define TASK_THREADS_NONPERIODIC_OFFSET 3


unsigned char task_threads_activity;
pthread_mutexattr_t mattr;
pthread_mutex_t  mutex_task_threads_activity;
pthread_t task_threads_pids[TASK_THREADS_NUM];
sem_t tthread_sems[TASK_THREADS_NONPERIODIC_NUM];
XGpio gpDIP, gpPUSH, gpLED; //PB device instance.

pthread_t tid1, tid2;
extern void* clock_main (void *);

static pid_t spid;
static pthread_t tid;
static pthread_attr_t attr;
static p_stat shell_ps;
static struct sched_param spar;
extern volatile int hrs, mins, secs, tot_secs;


void task() {
	xil_printf("Wörk wörk");
}

static void gpDIPIntHandler(void *arg) //Should be very short (in time). In a practical program, don't print etc.
{
	unsigned char val;
//clear the interrupt flag. if this is not done, gpio will keep interrupting the microblaze.--
	XGpio_InterruptClear(&gpDIP, 1);

	val = XGpio_DiscreteRead(&gpDIP, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);
}

static void gpPUSHIntHandler(void *arg) //Should be very short (in time). In a practical program, don't print etc.
{
	unsigned char val;
	int my_id = 0;
//clear the interrupt flag. if this is not done, gpio will keep interrupting the microblaze.--
	XGpio_InterruptClear(&gpPUSH, 1);

	val = XGpio_DiscreteRead(&gpPUSH, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);
}

void* periodic_thread(void* arg) {
	int i;
	unsigned char tmp;
	int my_id = *((int*)arg);


	while (1) {
		// First check if I am active?
		pthread_mutex_lock(&mutex_task_threads_activity);
		tmp = task_threads_activity;
		pthread_mutex_unlock(&mutex_task_threads_activity);

		tmp >>= my_id;
		tmp &= 0x01;

		if(tmp == 1) {
			// Active
			task();
			sleep(2);
		} else {
			usleep(50);
		}

	}
}

void* thread_tut_func_1() {
	int i;
	while (1) {
		xil_printf("crta---------------------------------------\r\n");
		for (i = 0; i < 10000; i++);
		sys_sleep(4000);
		usleep(20);
	}
}

void start_clock()
{
    int ret;

    pthread_attr_init(&attr);                                                          /* Need to launch a thread */
    spar.sched_priority = 0;
    pthread_attr_setschedparam(&attr,&spar);

    ret = pthread_create(&tid, &attr, (void*)clock_main, NULL);

    if (ret != 0) {
        xil_printf ("-- ERROR (%d) launching clock thread. Clock services unavailable...\r\n", ret);
    }

}

void clear()
{
    int i = 0 ;
    for(; i < 80; i++ ) {
	outbyte('\r') ; outbyte('\n') ;
    }
}

void shell_main(void* arg) {
	print("SHELL: Starting clock...\r\n");
	start_clock();
	print("\r\n\r\n");
	clear();

	unsigned char val;
	int Status;
	int ret, retval_tmp, i;

	// Initialise mutex and semaphores
	retval_tmp = pthread_mutexattr_init (&mattr);
	if (retval_tmp != 0) {
		xil_printf ("Error during pthread_mutexattr_init: %d.\r\n", retval_tmp);
		pthread_exit(NULL);
	}

	retval_tmp = pthread_mutex_init (&mutex_task_threads_activity, &mattr);
	if (retval_tmp != 0) {
		xil_printf ("Error during pthread_mutex_init: %d.\r\n", retval_tmp);
		pthread_exit(NULL);
	}

//	for(i = TASK_THREADS_NONPERIODIC_OFFSET; i < TASK_THREADS_NONPERIODIC_OFFSET + TASK_THREADS_NONPERIODIC_NUM; i++) {
//		if( sem_init(&tthread_sems[i], 1, 1) < 0 ) {
//			print("SEM: Error while initializing semaphore 1.\r\n");
//			pthread_exit(NULL);
//		}
//	}

	// Initialise LED
	Status = XGpio_Initialize(&gpLED, XPAR_LED_GPIO_DEVICE_ID);
	XGpio_SetDataDirection(&gpLED, 1, 0x00000000);
	XGpio_DiscreteWrite(&gpLED, 1, 0x00);
	print("Initializing DIP\r\n");

	// Initialise the DIP instance & PUSH
	Status = XGpio_Initialize(&gpDIP, XPAR_DIP_GPIO_DEVICE_ID);
	Status = XGpio_Initialize(&gpPUSH, XPAR_PUSH_GPIO_DEVICE_ID);

	// Set DP & PUSH gpio direction to input.
	XGpio_SetDataDirection(&gpDIP, 1, 0x000000FF);
	XGpio_SetDataDirection(&gpPUSH, 1, 0x000000FF);

	print("Enabling DIP interrupts\r\n");
	//global enable
	XGpio_InterruptGlobalEnable(&gpDIP);
	// interrupt enable. both global enable and this function should be called to enable gpio interrupts.
	XGpio_InterruptEnable(&gpDIP, 1);
	//register the handler with xilkernel
	register_int_handler(XPAR_AXI_INTC_0_DIP_GPIO_IP2INTC_IRPT_INTR,
			gpDIPIntHandler, &gpDIP);
	//enable the interrupt in xilkernel
	enable_interrupt(XPAR_AXI_INTC_0_DIP_GPIO_IP2INTC_IRPT_INTR);
	print("DIP int enabled\r\n");
	print("Enabling PUSH interrupts\r\n");
	//global enable
	XGpio_InterruptGlobalEnable(&gpPUSH);

	// interrupt enable. both global enable and this function should be called to enable gpio interrupts.
	XGpio_InterruptEnable(&gpPUSH, 1);
	//register the handler with xilkernel
	register_int_handler(XPAR_AXI_INTC_0_PUSH_GPIO_IP2INTC_IRPT_INTR,
			gpPUSHIntHandler, &gpPUSH);
	//enable the interrupt in xilkernel
	enable_interrupt(XPAR_AXI_INTC_0_PUSH_GPIO_IP2INTC_IRPT_INTR);
	print("PUSH int enabled\r\n");

	// Write starting state
	val = XGpio_DiscreteRead(&gpDIP, 1);
	XGpio_DiscreteWrite(&gpLED, 1, val);

	//start thread 1
	ret = pthread_create(&tid1, NULL, (void*) thread_tut_func_1, NULL );
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_tut_func_1...\r\n", ret);
	} else {
		xil_printf("Thread 1 launched with ID %d \r\n", tid1);
	}

//	// Start periodic threads
//	for(int i = 0; i < TASK_THREADS_PERIODIC_NUM; i++) {
//
//	}
//
//	// Start nonperiodic threads
//	for() {
//
//	}
}

int main ()
{
	xil_printf("Main started!\r\n");
    xilkernel_main ();
}

//int main_example() {
//	print("-- Entering main() --\r\n");
////Initialize Xilkernel
//	xilkernel_init();
////Add main_prog as the static thread that will be invoked by Xilkernel
//	xmk_add_static_thread(main_prog, 0);
////Start Xilkernel
//	xilkernel_start();
//	/* Never reached */
//	return 0;
//}
